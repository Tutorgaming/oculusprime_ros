#!/usr/bin/env python

"""relay ros twist messages to java movement commands
control speed via sensed odometry -- pid attempt
"""

# rostopic pub -r 5 /cmd_vel geometry_msgs/Twist '{linear: {x: 0.15, y: 0, z: 0}, angular: {x: 0, y: 0, z: 0}}'
# rosrun turtlesim turtle_teleop_key

import rospy
import socketclient
from geometry_msgs.msg import Twist
from nav_msgs.msg import Odometry
from math import radians


def twistCallback(data): # event handler for cmd_vel Twist messages
	global lastmove, checkmove, lastlinear, lastangular, direction
	lastmove = rospy.get_time()
	checkmove = True
	if data.linear.x > 0:  # forward (overrides angular)
		if not data.linear.x == lastlinear:
			direction = "forward" 
			lastlinear = data.linear.x
			lastangular = 0
			sendMove()
		
	elif data.linear.x < 0: # backward (overrides angular)
		if not data.linear.x == lastlinear:
			direction = "backward"
			lastlinear = data.linear.x
			lastangular = 0
			sendMove()
			
	elif data.angular.z > 0: # left
		if not data.angular.z == lastangular: 
			direction = "left"
			lastangular = data.angular.z
			lastlinear = 0
			sendMove()
			
	elif data.angular.z < 0: # right
		if not data.angular.z == lastangular: 
			direction = "right"
			lastangular = data.angular.z
			lastlinear = 0
			sendMove()
			
	else: # stop
		checkmove = False
		lastangular = 0
		lastlinear = 0
		socketclient.sendString("move stop")


# check if abs(speed) meets abs(target). that's all
def odomCallback(data):
	global motorPWM, integral, previous_error, previousMotorPWM, prev_pid_time
	Kp = 350
	Ki = 50 
	Kd = 0
	pid_dt_duration = rospy.Time.now() - prev_pid_time
	pid_dt = pid_dt_duration.to_sec()
	prev_pid_time = rospy.Time.now()
	
	if pid_dt < 0.2: #too soon 
		return

	if not lastlinear == 0:
		vel = abs(data.twist.twist.linear.x)
		target = abs(lastlinear)
	elif not lastangular == 0:
		vel = abs(data.twist.twist.angular.z)
		target = abs(lastangular)
	else: #stopped
		return
	
	error = target - vel
	integral = integral + (error * pid_dt)
	derivative = (error - previous_error) / pid_dt
	previous_error = error
	previousMotorPWM = motorPWM
	motorPWM = (Kp * error) + (Ki * integral) + (Kd * derivative)
	
	if motorPWM > 255:
		motorPWM = 255
	if motorPWM < 0:
		motorPWM = 0
	integral = integral - (error * pid_dt)
	if not previousMotorPWM == motorPWM:
		print(int(motorPWM))
		socketclient.sendString("speed "+str(int(motorPWM)))
		socketclient.sendString("move "+direction)
		previousMotorPWM = motorPWM

def sendMove():
	global motorPWM, direction
	socketclient.sendString("speed "+str(motorPWM))
	socketclient.sendString("move "+direction)

def getmotorpwmLinear(mps): 
	"""max speed pwm 255 = 0.39m/s
	min speed pwm 30 = 0.12m/s
	sysvolts 11.88
	"""
	motorpwm = 0
	maxspeed = 0.39
	minspeed = 0.12
	maxpwm = 255
	minpwm = 30
	if mps >= maxspeed: 
		motorpwm = 255
	elif mps < minspeed:
		motorpwm = 0
	else:
		motorpwm = minpwm + (maxpwm-minpwm)*(mps-minspeed)/(maxspeed-minspeed)
	return int(motorpwm)

def getmotorpwmAngular(rps): 
	"""max speed pwm 255 = 2.15r/s
	min speed pwm 30 = 0.36r/s
	sysvolts 11.88
	"""
	motorpwm = 0
	maxspeed = 2.15
	minspeed = 0.36
	maxpwm = 255
	minpwm = 30
	if mps >= maxspeed: 
		motorpwm = 255
	elif mps < minspeed:
		motorpwm = 0
	else:
		motorpwm = minpwm + (maxpwm-minpwm)*(mps-minspeed)/(maxspeed-minspeed)
	return int(motorpwm)

# MAIN

rospy.init_node('base_controller', anonymous=False)

lastlinear = 0
lastangular = 0
lastmove = 0
checkmove = False
direction = "stop"

prev_pid_time = rospy.Time.now()
motorPWM = 0
integral = 0
previous_error = 0
previousMotorPWM = 0

rospy.Subscriber("odom", Odometry, odomCallback) # TODO: testing only
rospy.Subscriber("cmd_vel", Twist, twistCallback)
rospy.Subscriber("turtle1/cmd_vel", Twist, twistCallback) # TODO: testing only

# publish stop if no updates
cmd_vel = rospy.Publisher('/cmd_vel', Twist)
while not rospy.is_shutdown():
	t = rospy.get_time()
	if checkmove and t - lastmove > 0.5: 
		cmd_vel.publish(Twist())  
	rospy.sleep(0.1) 

# stop wheels if necessary on shutdown
if not lastlinear==0 or not lastangular==0:
	socketclient.sendString("move stop")

