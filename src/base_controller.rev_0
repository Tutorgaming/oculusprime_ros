#!/usr/bin/env python
import rospy
import socketclient
from geometry_msgs.msg import Twist
import thread
from math import radians

nominalmaxmps = 0
nominalmaxrps = 0
lastlinear = 0
lastangular = 0
lastmove = 0
lastspeed = 0
checkmove = False

# rostopic pub -r 5 /cmd_vel geometry_msgs/Twist '{linear: {x: 0.1, y: 0, z: 0}, angular: {x: 0, y: 0, z: 0}}'
# rosrun turtlesim turtle_teleop_key

def callback(data): # event handler for cmd_vel Twist messages
	global lastmove, checkmove, lastlinear, lastangular, lastspeed
	lastmove = rospy.get_time()
	checkmove = True
	if data.linear.x > 0:  # forward (overrides angular)
		if not data.linear.x == lastlinear:
			motorspeed = getMotorSpeedLinear(data.linear.x)
			lastlinear = data.linear.x
			lastangular = 0
			if not motorspeed == lastspeed:
				socketclient.sendString("speed "+str(motorspeed))
				lastspeed = motorspeed
			socketclient.sendString("move forward")
		
	elif data.linear.x < 0: # backward (overrides angular)
		if not data.linear.x == lastlinear:
			motorspeed = getMotorSpeedLinear(abs(data.linear.x))
			if not motorspeed == lastspeed:
				socketclient.sendString("speed "+str(motorspeed))
				lastspeed = motorspeed
			socketclient.sendString("move backward")
			lastlinear = data.linear.x
			lastangular = 0
		
	elif data.angular.z > 0: # left
		if not data.angular.z == lastangular: 
			motorspeed = getMotorSpeedAngular(data.angular.z)
			if not motorspeed == lastspeed:
				socketclient.sendString("speed "+str(motorspeed))
				lastspeed = motorspeed
			socketclient.sendString("move left")
			lastangular = data.angular.z
			lastlinear = 0
		
	elif data.angular.z < 0: # right
		if not data.angular.z == lastangular: 
			motorspeed = getMotorSpeedAngular(abs(data.angular.z))
			if not motorspeed == lastspeed:
				socketclient.sendString("speed "+str(motorspeed))
				lastspeed = motorspeed
			socketclient.sendString("move right")
			lastangular = data.angular.z
			lastlinear = 0
	
	else: # stop
		checkmove = False
		lastangular = 0
		lastlinear = 0
		socketclient.sendString("move stop")



def listener(): # listen for cmd_vel Twist messages
	rospy.init_node('base_controller', anonymous=False)
	rospy.Subscriber("cmd_vel", Twist, callback)
	rospy.Subscriber("turtle1/cmd_vel", Twist, callback) # TODO: testing
	rospy.spin() 
    
def getMotorSpeedLinear(mps): 
	motorspeed = 255
	if mps < nominalmaxmps: 
		motorspeed = mps/nominalmaxmps * 255  # way too fast
	return int(motorspeed)

def getMotorSpeedAngular(rps): 
	motorspeed = 255
	if rps < nominalmaxrps:
		motorspeed = rps/nominalmaxrps * 255   # way too fast
	return int(motorspeed)
	
def stopMove(): # Thread: stop movement if no movement commands
	global lastmove, checkmove, lastlinear, lastangular
	cmd_vel = rospy.Publisher('/cmd_vel', Twist)
	
	while True:
		t = rospy.get_time()
		if checkmove and t - lastmove > 0.5: 
			# lastangular = 0
			# lastlinear = 0
			# socketclient.sendString("move stop")
			# checkmove = False
			cmd_vel.publish(Twist())  #odom node needs empty twist message to allow for deccel
		rospy.sleep(0.1) 


# MAIN

rospy.init_node('base_controller', anonymous=False)
rospy.Subscriber("cmd_vel", Twist, callback)
rospy.Subscriber("turtle1/cmd_vel", Twist, callback) # TODO: testing

# get nominal seconds per meter
socketclient.sendString("readsetting onemeterdelay")
s = socketclient.waitForReplySearch("<messageclient> setting onemeterdelay")
nominalmaxmps = 1000/float(s.split()[3])

# get seconds per 360deg
socketclient.sendString("readsetting fullrotationdelay")
s = socketclient.waitForReplySearch("<messageclient> setting fullrotationdelay")
nominalmaxrps = radians(360000/float(s.split()[3]))

thread.start_new_thread( stopMove, () ) # run as separate thread since listener() below is blocking

rospy.spin() # wait for shutdown

# stop wheels if necessary on shutdown
if not lastlinear==0 or not lastangular==0:
	socketclient.sendString("move stop")

	
